import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    )

    const { user_id, oponente_id } = await req.json()

    // Buscar skills equipadas
    const { data: userSkills } = await supabase
      .from('user_skills')
      .select('slot, skills(id, name, cooldown)')
      .eq('user_id', user_id)
      .lte('slot', 6)
      .order('slot')

    const { data: opponentSkills } = await supabase
      .from('user_skills')
      .select('slot, skills(id, name, cooldown)')
      .eq('user_id', oponente_id)
      .lte('slot', 6)
      .order('slot')

    const userSkillsArray = userSkills || []
    const opponentSkillsArray = opponentSkills || []

    // Fila de skills por slot
    const userQueue = userSkillsArray.map(s => ({
      id: s.skills.id,
      name: s.skills.name,
      cooldown: s.skills.cooldown,
      last_used: -999
    }))

    const opponentQueue = opponentSkillsArray.map(s => ({
      id: s.skills.id,
      name: s.skills.name,
      cooldown: s.skills.cooldown,
      last_used: -999
    }))

    // Escolher próxima skill disponível
    const escolherSkill = (queue: any[], turno: number, index: { value: number }) => {
      if (queue.length === 0) return null

      const total = queue.length
      for (let i = 0; i < total; i++) {
        const idx = (index.value + i) % total
        const skill = queue[idx]
        
        // Verifica se skill está disponível (cooldown)
        if (turno - skill.last_used >= skill.cooldown) {
          skill.last_used = turno
          index.value = (idx + 1) % total // Avança para próxima skill
          return { id: skill.id, name: skill.name }
        }
      }
      
      // Nenhuma skill disponível
      index.value = (index.value + 1) % total
      return null
    }

    const log: any[] = []
    let userIndex = { value: 0 }
    let opponentIndex = { value: 0 }
    const MAX_TURNOS = 15

    // Loop de turnos
    for (let turno = 1; turno <= MAX_TURNOS; turno++) {
      const turnoLog: any = { turno, actions: [] }

      // User escolhe skill
      const userSkill = escolherSkill(userQueue, turno, userIndex)
      turnoLog.actions.push({
        actor: 'user',
        skill: userSkill?.name || 'Ataque Básico',
        skill_id: userSkill?.id || 0
      })

      // Opponent escolhe skill
      const opponentSkill = escolherSkill(opponentQueue, turno, opponentIndex)
      turnoLog.actions.push({
        actor: 'opponent',
        skill: opponentSkill?.name || 'Ataque Básico',
        skill_id: opponentSkill?.id || 0
      })

      log.push(turnoLog)
    }

    // Salvar no banco (opcional)
    await supabase.from('batalhas').insert({
      user_id,
      oponente_id,
      vencedor_id: user_id, // Placeholder
      log_turnos: log,
    })

    return new Response(
      JSON.stringify({
        log_turnos: log,
        user_skills: userSkillsArray.map(s => s.skills.name),
        opponent_skills: opponentSkillsArray.map(s => s.skills.name)
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 400, headers: corsHeaders }
    )
  }
})